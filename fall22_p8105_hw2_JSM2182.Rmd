---
title: "Homework 2"
author: "Jennifer Mizhquiri Barbecho"
output: github_document
---

```{r, echo = FALSE, message = FALSE}
library(tidyverse)
library(readxl) #excel
library(ggplot2)
```



# Problem 1

`
```{r, message = FALSE}
nyctransit_df = 
  read_csv("./data/NYC_Transit_Subway_Entrance_And_Exit_Data.csv") %>%
  janitor::clean_names() %>% # figure out how to make NAs blank
  select(line:entry, vending, ada) %>% 
  mutate(entry = recode(entry, "YES" = 1, "NO" = 0)) #when to use <-

```
```{r}
head(nyctransit_df)
```
This dataset contains administrative, compliance, and geographic data on the NYC transit system. It has `r ncol(nyctransit_df)` columns and `r nrow(nyctransit_df)` rows. At this point, the variable names have been cleaned and one variable (entry) has been recoded so that it is a 0 or 1 instead of a character. Other aspects of the data have not been further inspected so it is not tidy. 

_Additional information_

```{r addl_data, include = FALSE}
nyctransit_df %>%
  distinct(station_name, line) #is there a way for me to get the count in line


```
There are `r nrow(nyctransit_df %>% distinct(station_name,line))` distinct stations in the dataset. 
```{r, echo = FALSE}

nyctransit_df %>%
  filter(ada == TRUE) %>% 
  distinct(station_name, line) 
  
```

There are `r nrow(nyctransit_df %>% filter(ada == TRUE) %>% distinct(station_name, line))` stations that are ADA compliant. 

```{r, echo = FALSE}


  nyctransit_df %>%
  filter(vending == "NO") %>% 
  group_by(entry) %>% 
  summarize(vending_entrance = n())


#how to set it so that the false can be explicitly stated if I decided to mutate a variable 
#how to set it so that the code divides it for me as it didn't seem straightforward
```
 `r 69/(114+69)` % of stations with no vending allow entrance.

_reformat the data_

```{r, eval = FALSE}
nyctransit_long = 
  nyctransit_df %>% 
  mutate(
    route8 = as.character(route8)) %>% 
  pivot_longer(
    nyctransit_df, route1:route11,
    names_to = "route_num",
    names_prefix = "route",
    values_to = "route_name") %>% 
  mutate(
    route_num = factor(route_num)
  )
  

```
### Problem 1

Below we import and clean data from `NYC_Transit_Subway_Entrance_And_Exit_Data.csv`. The process begins with data import, updates variable names, and selects the columns that will be used in later parts fo this problem. We update `entry` from `yes` / `no` to a logical variable. As part of data import, we specify that `Route` columns 8-11 should be character for consistency with 1-7.

```{r}
trans_ent = 
  read_csv(
    "data/NYC_Transit_Subway_Entrance_And_Exit_Data.csv",
    col_types = cols(Route8 = "c", Route9 = "c", Route10 = "c", Route11 = "c")) %>% 
  janitor::clean_names() %>% 
  select(
    line, station_name, station_latitude, station_longitude, 
    starts_with("route"), entry, exit_only, vending, entrance_type, 
    ada) %>% 
  mutate(entry = ifelse(entry == "YES", TRUE, FALSE))
```

As it stands, these data are not "tidy": route number should be a variable, as should route. That is, to obtain a tidy dataset we would need to convert `route` variables from wide to long format. This will be useful when focusing on specific routes, but may not be necessary when considering questions that focus on station-level variables. 

The following code chunk selects station name and line, and then uses `distinct()` to obtain all unique combinations. As a result, the number of rows in this dataset is the number of unique stations.

```{r}
trans_ent %>% 
  select(station_name, line) %>% 
  distinct
```

The next code chunk is similar, but filters according to ADA compliance as an initial step. This produces a dataframe in which the number of rows is the number of ADA compliant stations. 

```{r}
trans_ent %>% 
  filter(ada == TRUE) %>% 
  select(station_name, line) %>% 
  distinct
```

To compute the proportion of station entrances / exits without vending allow entrance, we first exclude station entrances that do not allow vending. Then, we focus on the `entry` variable -- this logical, so taking the mean will produce the desired proportion (recall that R will coerce logical to numeric in cases like this).

```{r}
trans_ent %>% 
  filter(vending == "NO") %>% 
  pull(entry) %>% 
  mean
```

Lastly, we write a code chunk to identify stations that serve the A train, and to assess how many of these are ADA compliant. As a first step, we tidy the data as alluded to previously; that is, we convert `route` from wide to long format. After this step, we can use tools from previous parts of the question (filtering to focus on the A train, and on ADA compliance; selecting and using `distinct` to obtain dataframes with the required stations in rows).

```{r}
trans_ent %>% 
  pivot_longer(
    route1:route11,
    names_to = "route_num",
    values_to = "route") %>% 
  filter(route == "A") %>% 
  select(station_name, line) %>% 
  distinct

trans_ent %>% 
  pivot_longer(
    route1:route11,
    names_to = "route_num",
    values_to = "route") %>% 
  filter(route == "A", ada == TRUE) %>% 
  select(station_name, line) %>% 
  distinct
```

# Problem 2

_Mr. Trash wheel dataset_
  * I am adding a variable wheel with value of "mr" applying to all obs, for later merging.

```{r, echo = FALSE, message = FALSE}
mrwheels_df = 
  read_excel(
    "data/Trash-Wheel-Collection-Totals-7-2020-2.xlsx", 
    sheet = "Mr. Trash Wheel", range = "A2:N535") %>% 
  janitor::clean_names() %>% 
  drop_na(dumpster) %>% 
  mutate(
    wheel = "mr",
    sports_balls = as.integer(round(sports_balls),
    dumpster = as.character(dumpster))
  )
```


_Professor Trashwheel dataset_ 
  * I am adding a variable wheel with value of prof and applying to all obs

 *  note that in professor wheels dumpster variable was numeric. to make it match what is in mr trashwheels, the variable is converted to character


```{r, echo = FALSE, message = FALSE}
profwheels_df = 
  read_excel(
    "data/Trash-Wheel-Collection-Totals-7-2020-2.xlsx", 
    sheet = "Professor Trash Wheel", range = "A2:N117") %>% 
  janitor::clean_names() %>% 
  drop_na(dumpster) %>%
  mutate(
    wheel = "prof",
    sports_balls = as.integer(round(sports_balls)),
    dumpster = as.character(dumpster)
  )
```

Combine both datasets into combo_wheels
```{r, echo = FALSE, message = FALSE}
combo_wheels_tidy = 
  bind_rows(mrwheels_df, profwheels_df) %>%
  janitor::clean_names()
```

_About the combined dataset_

There are `r nrow(combo_wheels_tidy)` observations in the resulting dataset. This dataset demonstrates various categories of collected items (i.e. sports balls, glass bottles, trash bottles) by weight (in tons), across years (2014 - 2021). This is helpful for generating summary stats on output and can help compare productivity between Mr. Trashwheels and Professor Trashwheels. For example, Mr. Trashwheel collected `r combo_wheels_tidy %>% filter(wheel == "prof") %>%  select(weight_tons) %>% sum()` tons, and in the year 2020, Mr. Trashwheels collected `r combo_wheels_tidy %>% filter( wheel == "mr", year == 2020) %>% select(sports_balls) %>% sum()` sports balls. 


# Problem 3

Import and clean pols-month.csv
 * note: data is sorted by year and month
 * year and month were moved to become the leading columns
 * month is a character variable and each value is renamed to their corresponding month
 * president variable was created to denote affiliation (i.e. dem = Democrat; gop = GOP)
 * FYI the dummy variable was dropped although the indicator variable of 0, 1 is false across select rows where they are listed as 2. This would require further inspection. 
 
```{r, echo = FALSE}
pols_df = 
  read_csv("data/fivethirtyeight_datasets/pols-month.csv") %>% 
  janitor::clean_names() %>%
  separate(mon, into = c("year", "month", "day"), sep = "-") %>% 
  mutate(
    year = as.integer(year),
    month = recode(month, "01" = "January", "02" = "February", "03" = "March", "04" = "April", "05" = "May", "06" = "June", "07" = "July", "08" = "August", "09" = "September", "10" = "October", "11" = "November", "12" = "December")) %>% 
  pivot_longer(
    cols = c('prez_dem','prez_gop'),
    names_to = "president", 
    names_prefix = "prez_",
    values_to = "dummy") %>% 
  select(-dummy, -day) %>% 
  select(year, month, everything()) %>% #does select always need to be broken down like this. yes.
  arrange(year, month)
  
```
```{r}
head(pols_df)
```

Import and clean snp.csv
 * note: data is sorted by year and month
 * year and month were moved to become the leading columns
 * month is a character variable and each value is renamed to their corresponding month
 * president variable was created to denote affiliation (i.e. dem = Democrat; gop = GOP)
 
```{r, echo = FALSE}
snp_df = 
  read_csv("data/fivethirtyeight_datasets/snp.csv") %>% 
  janitor::clean_names() %>%
  mutate(
    date = lubridate::mdy(date)) %>% 
  separate(col = date, into = c("year", "month", "day"), convert = TRUE, sep = "-") %>%
  mutate(
    month = recode(month, "1" = "January", "2" = "February", "3" = "March", "4" = "April", "5" = "May", "6" = "June", "7" = "July", "8" = "August", "9" = "September", "10" = "October", "11" = "November", "12" = "December")) %>%
  select(year, month, everything()) %>% 
  select(-day) %>% 
  arrange(year, month)

#you can try to use lubridate by using bracket and the dataset name 
#you can try to recode based on this by adding the 2000 to a certain range
```
```{r}
head(snp_df)
```

```{r, echo = FALSE}
unemp_df = 
  read_csv("data/fivethirtyeight_datasets/unemployment.csv") %>% 
  janitor::clean_names() %>% 
  pivot_longer(
    jan:dec,
    names_to = "month",
    values_to = "unemp_freq") %>% 
  mutate(
    year = as.integer(year),
    month = recode(month, "jan" = "January", "feb" = "February", "mar" = "March", "apr" = "April", "may" = "May", "jun" = "June",  "jul" = "July", "aug" = "August", "sep" = "September", "oct" = "October", "nov" = "November", "dec" = "December" )) %>% 
  select(year, month, everything()) %>% 
  arrange(year, month)

```

```{r}
head(unemp_df)
```


_Joining SNP TO POLS_
* in which pols is the given x data set with `r ncol(pols_df)` columns
* in which snp is the given y data set with `r ncol(snp_df)` columns

```{r}
pols_snp_df = 
  left_join(pols_df, snp_df, by = c("year" = "year", "month" = "month"))
```
  
_Joining unemployment to the SNP/POLS merged dataset_

```{r}
pols_snp_unemp_df = 
  left_join(pols_snp_df, unemp_df, by =  c("year" = "year", "month" = "month"))
```

_Combined dataset_
```{r}
head(pols_snp_unemp_df)
```


The resulting combined dataset is `r ncol(pols_snp_unemp_df)` columns by `r nrow(pols_snp_unemp_df)` rows. The year span is `r pols_snp_unemp_df %>% pull(year) %>% min()` to `r pols_snp_unemp_df %>% pull(year) %>% max()`. Key data include the frequency of senators, governors, and representatives by party affiliation, the party affiliation of the president, the close number, and the unemployment rates, all by year and month.